"use strict";

var assert = require("assert");
var error = require("./../lib/error");
var core = require("./core");


function isSpreadElement(node) {
	return node && node.type === 'SpreadElement';
}

function isArrayExpression(node) {
	return node && node.type === 'ArrayExpression';
}

function isSequenceExpression(node) {
	return node && node.type === 'SequenceExpression';
}

function isFunction(node) {
	var type;
	return node && (type = node.type)
		&& type === "FunctionDeclaration" || type === "FunctionExpression" || type === "ArrowFunctionExpression";
}

var SymbolIteratorBody = "typeof Symbol!=='undefined'&&Symbol.iterator||'@@iterator'";
var callIteratorBody =
	"(v,f){" +
		"if(v){" +
			"if(Array.isArray(v))return f?v.slice():v;" +
			"var i,r;"+
			"if(typeof v==='object'&&typeof (f=v[${Symbol_iterator}])==='function'){" +
				"i=f.call(v);r=[];" +
			"}" +
			"else if((v+'')==='[object Generator]'){" +
				"i=v;" +
				"r=[];" +
			"};" +
			"if(r) {" +
				"while((f=i['next']()),f['done']!==true)r.push(f['value']);" +
				"return r;" +
			"}" +
		"}" +
		"throw new Error(v+' is not iterable')"+
	"};"
;

function findSpreadArgument(node) {
	var spreadIndex = -1;
	var elements;
	if( node && Array.isArray(elements = (node.elements || node["arguments"])) ) {
		elements.forEach(function(arg, i) {
			if( spreadIndex === -1 && isSpreadElement(arg) ) {
				spreadIndex = i;
			}
		});
	}
	return spreadIndex;
}

function getRange(node) {
	return node && (node.groupRange || node.range);
}

function getLastNotNullElementIndex(elements, index) {
	if ( index === void 0 )index = elements.length;

	var element = null;

	while( element == null && index > 0 ) {
		element = elements[--index];
	}

	return element === null ? -1 : index;
}
function createArrayHoles(holesCount) {
	return holesCount > 0
		? "(new Array(" + holesCount + "))"
		: ""
}

var plugin = module.exports = {
	reset: function() {

	}

	, setup: function(alter, ast, options) {
		if( !this.__isInit ) {
			this.reset();
			this.__isInit = true;
		}

		this.alter = alter;
		this.options = options;
	}

	, ':: CallExpression,NewExpression,ArrayExpression': function(node) {
		var spreadIndex = findSpreadArgument(node);
		if( spreadIndex !== -1 ) {
			var type = node.type;

			if ( type === "CallExpression" ) {
				this.replaceCallExpression(node);
			}
			else if ( type === "NewExpression" ) {
				this.replaceNewExpression(node, spreadIndex);
			}
			else if ( type === "ArrayExpression" && node.$despread !== true ) {
				this.replaceArrayExpression(node);
			}
		}
	}

	, replaceCallExpression: function(node) {
		var isMemberExpression = node.callee.type === "MemberExpression";
		var calleeType = isMemberExpression && node.callee.object.type;
		var isSimpleMemberExpression = isMemberExpression && (calleeType === "Identifier" || calleeType === "ThisExpression");
		var args = node["arguments"];
		var argsLength = args.length;

		assert(argsLength);

		var expressionBefore = ""
			, expressionInside = ""
		;

		if( isMemberExpression ) {
			if( isSimpleMemberExpression ) {
				expressionInside =
					".apply("
					+ this.alter.get(node.callee.object.range[0], node.callee.object.range[1])
					+ ", "
				;
			}
			else {
				var tempVar = core.getScopeTempVar(node.callee.object, node.$scope);

				this.alter.wrap(
					node.callee.object.range[0]
					, node.callee.object.range[1]
					, (core.detectSemicolonNecessity(node) ? ";" : "") + "(" + tempVar + " = "
					, ")"
				);

				expressionInside = ".apply(" + tempVar + ", ";

				core.setScopeTempVar(tempVar, node, node.$scope, true);
			}
		}
		else {
			expressionInside =
				".apply(null, "
			;

			if( node.callee.type === "FunctionExpression" ) {
				expressionBefore = "(";
				expressionInside = ")" + expressionInside;
			}
		}

		if( expressionBefore ) {
			this.alter.insertBefore(
				node.callee.range[0]
				, expressionBefore
			);
		}

		var needFirstSquareBracket = argsLength > 1
			|| isArrayExpression(args[0].argument)
				&& !isSpreadElement(args[0].argument.elements[0])
		;

		this.alter.replace(
			args.range[0]
			, getRange(args[0])[0]
			, expressionInside + (needFirstSquareBracket ? "[" : "")
		);
//		if ( !((argsLength === 1 && !isArrayExpression(args[0].argument)) ) ) {
//			console.log(argsLength, isArrayExpression(args[0].argument), args[0].argument, needFirstSquareBracket);
//			process.exit(0)
//		}


		this.replaceSpreads(node, args, true);
	}

	, replaceNewExpression: function(node, spreadIndex) {
		var bindFunctionName = core.bubbledVariableDeclaration(node.$scope, "BIND", "Function.prototype.bind");
		var args = node["arguments"];

		this.alter.insert(
			node.callee.range[0]
			, "(" + bindFunctionName + ".apply("
		);

		args.unshift({
			type: "Literal",
			value: null,
			raw: "null",
			range: [args.range[0] + 1, args.range[0] + 1]
		});

		this.alter.replace(// replace '(' from 'new test(...a)'
			args.range[0]
			, args.range[0] + 1
			, ", [null" + (spreadIndex === 0 && !isArrayExpression(args[1]["argument"]) ? "" : ", ")
		);

		this.replaceSpreads(node, args, true);

		this.alter.insertAfter(
			node.range[1]
			, ")()"
		);
	}

	, replaceArrayExpression: function(node) {
		// found new line symbols
		this.replaceSpreads(node);
	}

	, replaceSpreads: function(node, elements, innerSpread) {;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;;var $that$0=this;
		var self = this;

		function getCallIteratorFunctionName() {
			var Symbol_iterator = core.bubbledVariableDeclaration(node.$scope, "S_ITER", SymbolIteratorBody);
			return core.bubbledVariableDeclaration(node.$scope, "ITER", callIteratorBody.replace("${Symbol_iterator}", Symbol_iterator), true);
		}

		var nonSpreadElementStart = -1;
		function startNotSpreadElementsGroup(start) {
			if( nonSpreadElementStart === -1 ) {
				nonSpreadElementStart = start;
			}
		}
		function endNotSpreadElementsGroup(end) {
			if( nonSpreadElementStart < 0 )return;

			var startElement = elements[nonSpreadElementStart]
				, endElement = elements[end || elements.length - 1]
			;

			assert(!!startElement);

			if( !endElement ) {
				endElement = elements[getLastNotNullElementIndex(elements, end)];
			}

			self.alter
				.insertBefore(getRange(startElement)[0], "[")
				.insert(getRange(endElement)[1], "]")
			;

			nonSpreadElementStart = -1;
		}

		var firstElemIsSpreadFlag = -1, that = this;

		function removeFirstSquareBracket() {
			if ( firstElemIsSpreadFlag >= 0 ) {
				if( !concatOpen ) {
//					let _isArrayExpression = isArrayExpression(node);// for "NewExpression" and "CallExpression", node is not a SpreadElement
//					let from = _isArrayExpression ? node.range[0] : firstElemIsSpreadFlag;
					var from = firstElemIsSpreadFlag;

					that.alter.remove(from, from + 1);
				}
				firstElemIsSpreadFlag = -1;
			}
		}

		elements = elements || node.elements;

		var argsLength = elements.length;
		var callIteratorOpen = false, concatOpen = false, prevConcatOpen = false;
		var lastNullElementCount = 0, ArrayExpressionElementInInnerSpread = null;
		var callIteratorFunctionName, endString = "";
		var i = 0;

		for( ; i < argsLength ; i++ ) {(function(){
			var element = elements[i]
				, elementRange = getRange(element)
			;
			var isFirst = i === 0
				, isLast = i === argsLength - 1
				, isLastAndNull = isLast && element == null
				, theOnlyOne = isLast && isFirst
				, isSpreadEl = isSpreadElement(element)
			;

			prevConcatOpen = concatOpen;

			if( concatOpen ) {
				if( element || isLastAndNull ) {
					if( lastNullElementCount ) {
						var fistNullIndex = i - lastNullElementCount;

						if( isLastAndNull )lastNullElementCount++;// [1, ...a, , , , ] -> [1].concat(ITER(a), [ , , , ]) case

						if( !isSpreadEl ) {/* see: LINK createArrayHoles#1 */
							$that$0.alter.replace(
								getRange(elements[getLastNotNullElementIndex(elements, fistNullIndex)])[1]
								, isLastAndNull ? node.range[1] - 1 : elementRange[0]
								, (isFirst ? "" : ", ") + createArrayHoles(lastNullElementCount) + (isLastAndNull ? "" : ", ")
							);
						}

						lastNullElementCount = 0;
					}
				}
				else {
					lastNullElementCount++;
				}
			}

			if( isSpreadEl ) {
				var argument = element.argument
					, argumentRange = getRange(argument)
				;

				if( isArrayExpression(argument) ) {
					removeFirstSquareBracket();
					firstElemIsSpreadFlag = theOnlyOne && isSpreadElement(argument.elements[0]) ? argument.range[0] : -1;
					// link `spread_in_spread` 1
					// cases: [...[...obj]] and [...[N, , ...obj]], [...([...obj])] and [...([N, , ...obj])]
					$that$0.alter.remove(elementRange[0], argument.range[0] + (firstElemIsSpreadFlag === -1 ? 1 : 0), {a: 1});// remove "...[" or "...(["

					if ( argument.groupRange ) {
						// cases: [...([...obj])] and [...([N, , ...obj])]
						$that$0.alter.remove(argument.range[1], argument.groupRange[1], {a: 2});// remove ")" from "])"
					}
					var index;
					if ( !isLast
						&& (index = getLastNotNullElementIndex(argument.elements)) != argument.elements.length - 1
					) {
						// cases: [...[ , ], 1] -> [, 1], [...[2, ], 1] -> [2, 1]
						var start = index == -1 ? argument.range[0] + 1 : argument.elements[index].range[0]
							, end = argument.range[1] - 1
						;
						$that$0.alter.remove(start, end, {a: 3});// remove "," from "[ , ]"
					}

					if( !innerSpread || ArrayExpressionElementInInnerSpread ) {
						// link `spread_in_spread` 2
						// cases: [...[N, , ...obj]]
						$that$0.alter.remove(argument.range[1] - 1, argumentRange[1], {a: 4});// remove "]"
					}
					else {
						// FIXME: do something better
						ArrayExpressionElementInInnerSpread = argument;
					}

					elements.splice.apply(elements, [i, 1].concat(argument.elements));
					i--;
					argsLength = elements.length;

					argument.$despread = true;

					return;
				}
				else {
					endNotSpreadElementsGroup(i - 1);

					if( !callIteratorFunctionName ) callIteratorFunctionName = getCallIteratorFunctionName();

					var concatStr = concatOpen ? ", " :
						theOnlyOne
							? ""
							: ( (isFirst ? " " : "") + "].concat(" )
					;
					if( !concatOpen )concatOpen = !!concatStr;

					var callIteratorCloseStr = $that$0.__detectNeedToCloneSpreadVariable(argument, elements, i)
						? ", true)"
						: ")"
					;

					if( isFirst ) {
						// TODO:: one this.alter.replace
						var from = elementRange[0];
						if ( !innerSpread && !concatStr ) {
							do {
								--from;
							}
							while ( $that$0.alter.getRange(from, from + 1) !== "[" );
						}

						$that$0.alter.remove(//remove "[..." or "..."
							from
							, argumentRange[0], {a: 5}
						);
						$that$0.alter.insertBefore(
							argumentRange[0]
							, concatStr + callIteratorFunctionName + "("
						);
						if( !theOnlyOne && (concatOpen || callIteratorCloseStr) ) {
							$that$0.alter.insert(argumentRange[1], callIteratorCloseStr);
						}
//						else{
//							this.alter.remove(node.range[0], node.range[0] + 1);
//						}
					}
					else {
						var lastNotNullElementIndex = getLastNotNullElementIndex(elements, i);

						if( lastNotNullElementIndex === -1 ) {// [ , , ...spread] case
							var arrayHolesString = createArrayHoles(i);
							$that$0.alter.replace(
								node.range[0]
								, argumentRange[0]
								, arrayHolesString + ".concat([" + concatStr + callIteratorFunctionName + "("
							);
							endString = ")";
						}
						else {
							var arrayHolesString$0 = createArrayHoles(i - lastNotNullElementIndex - 1);/* LINK createArrayHoles#1 */
							if( arrayHolesString$0 ) {
								arrayHolesString$0 += ", ";
							}

							var from$0 = getRange(elements[lastNotNullElementIndex])[1]
								, to = argumentRange[0]
							;

							var lineBreaks = $that$0.alter.getRange(from$0, to).match(/[\r\n]/g) || [];
							var lineBreaksCount = lineBreaks.length;

							$that$0.alter.replace(
								from$0
								, argumentRange[0]
								, concatStr + arrayHolesString$0 + callIteratorFunctionName + "("
								, {transform: function(str) {
									var newLineBreaks = str.match(/[\r\n]/g) || [];
									var newLineBreaksCount = newLineBreaks.length;

									if ( newLineBreaksCount < lineBreaksCount ) {
										str = lineBreaks.slice(newLineBreaksCount).join("") + str;
									}
									return str;
								}}
							);
						}
						$that$0.alter.insert(argumentRange[1], callIteratorCloseStr);
					}

					callIteratorOpen = true;
				}
			}
			else if( concatOpen ) {
				if( element ) {
					startNotSpreadElementsGroup(i);
				}
				else {
					endNotSpreadElementsGroup(i);
				}
			}

			removeFirstSquareBracket();
		})();}
		endNotSpreadElementsGroup();

		if( endString ) {
			this.alter.insertBefore(node.range[1], endString, {extend: true});
		}

		if ( elements.length == 1 && !concatOpen && callIteratorOpen ) {
			if ( isArrayExpression(node) ) {// for "NewExpression" and "CallExpression", node is not a SpreadElement )
				this.alter.remove(node.range[0], node.range[0] + 1);
			}
		}

		if( (concatOpen || callIteratorOpen) ) {
			if( innerSpread ) {
				this.alter.insertBefore(node.range[1], ")", {extend: true});
				if( ArrayExpressionElementInInnerSpread ) {
					this.alter.remove(getRange(ArrayExpressionElementInInnerSpread)[1] - 1, getRange(ArrayExpressionElementInInnerSpread)[1], {a: 6});// remove "]"
					ArrayExpressionElementInInnerSpread = null;
				}
			}
			else {
				this.alter.replace(node.range[1] - 1, node.range[1], ")", {extend: true});
			}

		}
	}

	, __detectNeedToCloneSpreadVariable: function(variable, elements, startsFrom) {
		startsFrom = +startsFrom + 1;

		if( startsFrom >= elements.length )return false;
		if( isSequenceExpression(variable) )return true;// need more work to deep analise SequenceExpression
		if( variable.type !== "Identifier" )return false;

		elements = elements.slice(startsFrom);

		var variableName = variable.name;

		function checkElement(variableName, element, parentType) {
			var elementType = element.type;

			if( elementType === "Identifier" ) {
				return element.name === variableName
					&& parentType !== "Property"		// [...a, 0, {prop: a}]
					&& parentType !== "ArrayExpression"	// [...a, 0, [a]]
					&& parentType !== "SpreadElement"	// [...a, 0, ...a]
				;
			}
			else if( isSpreadElement(element) || elementType === "UpdateExpression" || elementType === "UnaryExpression" ) {
				return checkElement.call(this, variableName, element.argument, element.type);
			}
			else if( elementType === "BinaryExpression" ) {
				return checkElement.call(this, variableName, element.left)
					|| checkElement.call(this, variableName, element.right)
				;
			}
			else if( elementType === "MemberExpression" ) {
				return checkElement.call(this, variableName, element.object);
			}
			else if( elementType === "Property" ) {
				return checkElement.call(this, variableName, element.value, "Property");
			}
			else if( elementType === "ArrayExpression" ) {
				return checkManyElements.call(this, variableName, element.elements, elementType);
			}
			else if( elementType === "SequenceExpression" ) {
				return checkManyElements.call(this, variableName, element.expressions, elementType);
			}
			else if( elementType === "ObjectExpression" ) {
				return /*parentType !== "ArrayExpression" || */checkManyElements.call(this, variableName, element.properties, elementType);
			}
			else if( elementType === "CallExpression" ) {
				return true;
			}
			else if( elementType === "Literal" ) {
				return false;
			}
			else {
				// all other nodeS can affect to the original variable. Example: var arr = [1], a = [...arr, (()=>(arr.push(2),arr))()]
				return parentType !== "Property" && parentType !== "ArrayExpression";
			}
		}

		function checkManyElements(variableName, elements, parentType) {
			return elements.some(function(element) {
				return element && checkElement.call(this, variableName, element, parentType);
			}, this);
		}

		return checkManyElements(variableName, elements);
	}
};

for(var i in plugin) if( plugin.hasOwnProperty(i) && typeof plugin[i] === "function" ) {
	plugin[i] = plugin[i].bind(plugin);
}
